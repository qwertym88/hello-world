### 前言
以下内容坑了我一周。
### function类实现
基本思想还是很简单的，就是一个仿函数。
```c++
//function 类

...
#include<tuple>
#include<type_traits>
...

...
namespace simple{
    template<class R,class...Args>
    struct func_traits;
    //这里坑了我一个小时啊，声明应在最前，因为function类中用到了，而定义要放在最后，否则编译器不知道模板参数，会报一个“not a class template”的错误
    
    template<class Fn>
    class function{
      typedef typename std::decay<Fn>::type call_type;
      //此处int&和int无区别，而且编译器可能会聪明的加上一些修饰符（我们只能呵呵了），所以需要decay。
      typedef typename func_traits<call_type>::res_type result_type;
      call_type _call;
      public:
        function(call_type&& f):_call(f){};//至于此处的右值仅仅是为了加快传递速度而已，并没有什么用
        function& operator=(call_type&& f){
            _call=f;
            return *this;
        }
        template<class... P>
        result_type operator()(P&&... p){
            return _call(std::forward<P>(p)...);
        }
    };
    template <typename R, typename... P>//取普通函数、成员函数
    struct func_traits<R(*)(P...)> { 
        typedef R res_type; //返回值
        typedef std::tuple<P...> arg_type; //参数类型，此程序没用上
        
    };
    
    /* check member function */	//兼容函数cv符
    
    #define FUNC_TRAITS__(...) \
        template <typename R, typename C, typename... P> \
        struct func_traits<R(C::*)(P...) __VA_ARGS__> { typedef R type; };
    
    FUNC_TRAITS__()
    FUNC_TRAITS__(const)
    FUNC_TRAITS__(volatile)
    FUNC_TRAITS__(const volatile)
    
    #undef RESULT_TRAITS__
}
...

//test
int a(int&& x){
    std::cout<<0<<std::endl;
    return x;
}

int main(){
    simple::function<int(int&&)> func=&a;
    std::cout<<func(12);
    return 0;   
}
```
只是参数传递上需要动一些手脚。因为函数参数不确定，是个可变参数，常规方法是用一个tuple来存储。
