### 前言
以下内容坑了我一周。然鹅还需要更长时间。。。
### function类实现
基本思想还是很简单的，就是一个仿函数。
```c++
//function 类

...
#include<tuple>
#include<type_traits>
...

...
namespace simple{
    template<class R,class...Args>
    struct func_traits;
    //这里坑了我一个小时啊，声明应在最前，因为function类中用到了，而定义要放在最后，否则编译器不知道模板参数，会报一个“not a class template”的错误
    
    template<class Fn>
    class function{
      typedef typename std::decay<Fn>::type call_type;
      //此处int&和int无区别，而且编译器可能会聪明的加上一些修饰符（我们只能呵呵了），所以需要decay。
      typedef typename func_traits<call_type>::res_type result_type;
      call_type _call;
      public:
        function(call_type&& f):_call(f){};//至于此处的右值仅仅是为了加快传递速度而已，并没有什么用
        function& operator=(call_type&& f){
            _call=f;
            return *this;
        }
        template<class... P>
        result_type operator()(P&&... p){
            return _call(std::forward<P>(p)...);
        }
    };
    template <typename R, typename... P>//取普通函数、成员函数
    struct func_traits<R(*)(P...)> { 
        typedef R res_type; //返回值
        typedef std::tuple<P...> arg_type; //参数类型，此程序没用上
        
    };
    
    /* check member function */	//兼容函数cv符
    
    #define FUNC_TRAITS__(...) \
        template <typename R, typename C, typename... P> \
        struct func_traits<R(C::*)(P...) __VA_ARGS__> { typedef R type; };
    
    FUNC_TRAITS__()
    FUNC_TRAITS__(const)
    FUNC_TRAITS__(volatile)
    FUNC_TRAITS__(const volatile)
    
    #undef RESULT_TRAITS__
}
...

//test
int a(int&& x){
    std::cout<<0<<std::endl;
    return x;
}

int main(){
    simple::function<int(int&&)> func=&a;
    std::cout<<func(12);
    return 0;   
}
```
目前这个function类已经可以用于普通的函数了。但离我们的想法还差得远。但我的智商仅限于此了。
### 一个升级的版本
<del>观察原生的function类，会发现它需要声明时初始化。这并不是没有道理的。人为传入的模板参数（<>中的）只能作为类的标识（如果可以这么理解），而具体调用则需要根据初始化的数判定。所以应当会有两个Fn。</del>
我粗略看了一下functional源代码啊，发现它的处理方式挺简单的，就是再创建一个对象而已。但理论简单，实践希望也是如此。
