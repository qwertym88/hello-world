### 前言
本人一向很水，但看在我立了flag的缘故，不得不收起惰性，忍受着学校的迷之网速和极其明显的作业做不完的凉凉之感，在此为大家写。作为第二次，谨此纪念。
本篇为了体现我不是一个水货（虽然事实上就是），将讨论得深一点。

---

## 正文
先快速过一下基础知识。。。
### 函数模板
函数模板作为函数重载的“高级”版本，事实上作用早就超出了一般的重载。比如一个巧妙地获取数组长度的函数
```c++
template<class T,size_t N>
size_t len(T (&arr)[N]){
	return N;
}
```
它可以获取所有一般数组（不包括自定义容器），但在面对string等时有一个小bug（末尾有一个‘\n’,而很明显我们并不想算入数组长度），所以需要一个特例化的模板。
```c++
template<size_t N>
size_t len(char (&arr)[N]){
	return N-1;
}
```
大功告成。事实上，对任意容器，应该也可以用类似的办法获取长度（用迭代器？）
可参考[https://blog.csdn.net/lezardfu/article/details/56852043](https://blog.csdn.net/lezardfu/article/details/56852043)
### 类模板
与函数模板很像，只不过更加好玩。它可以传入常量参数，所以说它诞生了一个毁青春的东西，模板元编程。
### 模板元（搞笑的）
可参考:
* <https://www.cnblogs.com/qicosmos/p/4480460.html>
* 一本书,[模板元编程]( "下载pdf")
### 函数指针
实在没什么说的，上代码。
```c++
int foo(int a,int b){};
struct bar{
	int a(int b){};
}
typedef int(*pfn1)(int,int);
//通式： 返回类型（*变量名）（参数列表）= 函数名 //可不加 &
//通式2： 返回类型（*命名空间::变量名）（参数列表）= &命名空间::函数名 //必须有 &
int(*pfn2)(int,int) =foo;
//= pfn1 pfn2=foo
int(*bar::pfn3)(int)=&bar::a;
```